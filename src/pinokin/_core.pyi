from __future__ import annotations

import enum

import numpy as np
from numpy.typing import NDArray

class Robot:
    def __init__(self, urdf_path: str, ee_frame: str = "") -> None: ...
    @staticmethod
    def from_urdf_string(urdf_string: str, ee_frame: str = "") -> Robot: ...
    def fkine(self, q: NDArray[np.float64]) -> NDArray[np.float64]: ...
    def fkine_into(self, q: NDArray[np.float64], out: NDArray[np.float64]) -> None: ...
    def jacob0(self, q: NDArray[np.float64]) -> NDArray[np.float64]: ...
    def jacob0_into(self, q: NDArray[np.float64], out: NDArray[np.float64]) -> None: ...
    def jacobe(self, q: NDArray[np.float64]) -> NDArray[np.float64]: ...
    def batch_fk(self, joint_positions: NDArray[np.float64]) -> list[NDArray[np.float64]]: ...
    @property
    def name(self) -> str: ...
    @property
    def nq(self) -> int: ...
    @property
    def lower_limits(self) -> NDArray[np.float64]: ...
    @property
    def upper_limits(self) -> NDArray[np.float64]: ...
    @property
    def velocity_limits(self) -> NDArray[np.float64]: ...
    @property
    def qlim(self) -> NDArray[np.float64]: ...
    def set_ee_frame(self, name: str) -> None: ...
    def set_tool_transform(self, T_tool: NDArray[np.float64]) -> None: ...
    def clear_tool_transform(self) -> None: ...
    @property
    def has_tool_transform(self) -> bool: ...

class Method(enum.Enum):
    GN = ...
    NR = ...
    LM = ...

class Damping(enum.Enum):
    Chan = ...
    Wampler = ...
    Sugihara = ...

class BatchResult:
    joint_positions: NDArray[np.float64]
    valid: list[bool]
    all_valid: bool

class IKSolver:
    def __init__(
        self,
        robot: Robot,
        method: Method = Method.LM,
        damping: Damping = Damping.Sugihara,
        tol: float = 1e-6,
        lm_lambda: float = 1.0,
        max_iter: int = 30,
        max_restarts: int = 100,
        enforce_limits: bool = True,
    ) -> None: ...
    def solve(
        self,
        Tep: NDArray[np.float64],
        q0: NDArray[np.float64] | None = None,
    ) -> bool: ...
    def batch_ik(
        self,
        poses: list[NDArray[np.float64]],
        q_start: NDArray[np.float64],
    ) -> BatchResult: ...
    def set_we(self, we: NDArray[np.float64]) -> None: ...
    @property
    def q(self) -> NDArray[np.float64]: ...
    @property
    def success(self) -> bool: ...
    @property
    def residual(self) -> float: ...
    @property
    def iterations(self) -> int: ...
    @property
    def restarts(self) -> int: ...
